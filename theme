//App.vue
<template>
  <div id="app">
    <h1>我是来被测试的</h1>
    <el-select v-model="theme" placeholder="请选择" @change="handle_change()">
      <el-option
        v-for="item in options"
        :key="item.value"
        :label="item.label"
        :value="item.value">
      </el-option>
    </el-select>
    <div>
      <el-button>默认按钮</el-button>
      <el-button type="primary">主要按钮</el-button>
      <el-button type="success">成功按钮</el-button>
      <el-button type="info">信息按钮</el-button>
      <el-button type="warning">警告按钮</el-button>
      <el-button type="danger">危险按钮</el-button>
    </div>
    <router-view/>
  </div>
</template>

<script>
  import {mapState} from 'vuex'
export default {
  name: 'App',
  data () {
    return {
      options: [{
        value: 'yasuo',
        label: '主题一'
      },  {
        value: '1b1e24',
        label: '主题2'
      }],
      theme: 'yasuo'
    }
  },
  computed : {
    ...mapState(['themeColor'])
  },
  mounted () {
    //1.localStorage 保持状态
    if(localStorage.getItem('theme')) {
      console.log(localStorage.getItem('theme'))
    //  1.2有就直接拿来用
      this._toggleClass(document.body,`custom-${localStorage.getItem('theme')}`)
    //  1.2 同时让选项卡里面默认显示，我选择的那个主题
      this.theme = localStorage.getItem('theme')
    } else {
      console.log(localStorage.getItem('theme'),2)
      //1.2 没有就去 vuex中取出
      this._toggleClass(document.body,`custom-${this.themeColor}`)
    }
    //从vuex中取出默认主题类的名字

  },
  methods: {
    _toggleClass (ele, cla) {
     if(!ele || !cla) {
       return
     }
     ele.className = cla
    },
    handle_change () {
      console.log(this.theme,99)
      let data = this.theme
      //1.3 用户改变主题 跳过了vuex那步
      this.$store.commit('set_chemecolor',{data})
     // 1.3 保存用户改变主题, 好像不用和上面同步
      localStorage.setItem('theme',data)

    }
  },
  watch: {
    theme (n,o) {
      console.log(n,o)
      //感觉怎么都是 读取和调用是同步的 有点小困惑
      this._toggleClass(document.body,`custom-${this.themeColor}`)
    }
  }
}
</script>

<style lang="less" >
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
  & > h1 {
    background-color: #999999;
    line-height: 3;
  }
}
</style>




//自定义的组件实现动态切换ph
<template>
    <div >
      <p>我是一个p标签 <br> <span>我是一个span标签</span></p>

    </div>
</template>

<script>
    export default {
        name: "p-h"
    }
</script>

<style scoped lang="less">
//定义一个函数，把这个组件中的样式代码全部写入到 这个函数内
.theme (@backcolor:#EEA2AD,@fcolor:#fff) {
  div {
    background-color: @backcolor;
    width: 400px;
    height: 300px;
    p {
      font-size: 20px;
      color: @fcolor;
      /*text-align: left;*/
      span {
        background-color: @fcolor;
        font-size: 16px;
      }
    }
  }
}
//调用函数 在body上添加三套类名里面
.custom-yasuo {
  .theme()
}
.custom-1b1e24 {
  .theme(yellowgreen,gray)
}
</style>


//https://blog.csdn.net/young_Emily/article/details/78591261 
//https://blog.csdn.net/young_emily/article/details/78596219

//gulp
// gulpfile.js  放到根目录下
var path = require('path')
var gulp = require('gulp')
var cleanCSS = require('gulp-clean-css') //没必要添加进入到pack里面，就开发时用的上
var cssWrap = require('gulp-css-wrap')
gulp.task('css-wrap', function () {
  return gulp.src(path.resolve('./theme2/index.css'))    //依据根目录查找要压缩的css文件 ，这个css推荐使用官网在线生成的 在根目录生成一个theme文件夹
  /* 找需要添加命名空间的css文件，支持正则表达式 */
    .pipe(cssWrap({
      selector: '.custom-yasuo' /* 添加的命名空间 动态切换的类名，实际上就是给在线生成的类找一个公共的父亲，通过切换公共的类来实现换肤功能*/
    }))
    .pipe(cleanCSS())
    .pipe(gulp.dest('src/assets/css/theme/yasuo')) /* 存放的目录 */
})

